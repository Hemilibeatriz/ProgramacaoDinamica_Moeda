# -*- coding: utf-8 -*-
"""Programação Dinâmica - Problema das Moedas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fl3U7esl9lw-F1yshLoN3srVScC4bYl1

##Explicação do Problema das Moedas

A partir de um conjunto *S* de moedas **infinitas**, deseja-se determinar o número **mínimo** de moedas que satisfaça um troco de valor *V*

*S*[n] = {a0,a1,a2...an-1}

##Programação Dinâmica

- Modelo baseado em recursão
- Utiliza a técnica de Memorização
- Não pode ser aplicada quando existe dependência entre as respostas
- Geralmente oferece uma solução mais otimizada que a solução "convencional"

##Algoritmo
"""

#v = valor do troco que eu preciso retornar
v = 178
#moedas = moedas disponiveis para serem usadas - necessita ser valor inteiro
moedas = [1, 2, 5, 10, 20, 50, 100]
#n = quantidade de moedas 
n = len(moedas)

#Por ser programação dinâmica precisamos de uma estrutura de memória
#Aqui pega o valor do troco a ser devolvido (V+1) porque pelo range ele pega até o valor - 1 e n é a quantidade de moedas 
#Cria a matriz VxN (porque ele vai armazenando várias possíveis respostas para diferentes trocos até chegar na valor de troco que a gente quer)
#Compreensão de lista (List comprehension): Construção sintática para criação de uma lista baseada em listas existentes.
memoria = [[None for _ in range(v + 1)] for _ in range(n)]

#Função recebe o valor que precisa retornar de troco além do índice da moeda atual dentro do vetor moedas
def solucao(valor_restante, indice_moeda_atual = 0):
  #se valor_restante é 0, tem que voltar 0 de troco
  if valor_restante == 0:
    return 0
  #ainda tenho troco para devolver MAS estou na posição do indice_moeda_atual em n e vai só até n-1
  if valor_restante > 0 and indice_moeda_atual == n:
    return float('inf')
  #se valor_restante < 0 (pode ocorrer em "valor_restante - moedas[indice_moeda_atual]" supor valor_restante 3 e moedas[indice_moeda_atual] 5)
  if valor_restante < 0:
    return float('inf')
  #se ainda não foi calculado para essa posição eu passo pela lista de moedas e vejo se aquela moeda é ótima para o problema
  if memoria[indice_moeda_atual][valor_restante] is None:
    #coloco como 1(peguei) + passo para a função novamente o valor_restante - moeda que eu acabei de pegar(pelo indice) e eu seto que usei o indice 
    pego_moeda = 1 + solucao(valor_restante - moedas[indice_moeda_atual], indice_moeda_atual)
    #envio o valor_restante(que não mudou) e o indice posterior
    não_pego_moeda = solucao(valor_restante, indice_moeda_atual + 1)
    #guardo na memória o mínimo entre esses valores,
    memoria[indice_moeda_atual][valor_restante] = min(pego_moeda, não_pego_moeda)
  #se já foi calculado, eu pego o valor já calculado e apresento como resposta
  return memoria[indice_moeda_atual][valor_restante]

#printa a quantidade de moedas necessárias para voltar o troco de valor v
print(solucao(v))
#printa a matriz construída para chegar ao resultado
print(memoria)